<html lang="en-US">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta property="og:title" content="Particle Lenia 2D">
        <meta property="og:site_name" content="bendavidsteel.github.io">
        <meta property="og:image" content="/webgpu/particle-lenia-cover.png" />
        <meta property="og:image:height" content="630" />
        <meta property="og:image:width" content="1200" />
        <title>Particle Lenia 2D</title>
        <link rel="icon" type="image/x-icon" href="/blog/assets/favicon.ico">
        <style>
            html, body {
                margin: 0 !important;
                padding: 0 !important;
            }
        </style>
        <script>

// From https://stackoverflow.com/a/47593316/2315602
function splitmix32(a) {
    return function() {
        a |= 0;
        a = a + 0x9e3779b9 | 0;
        let t = a ^ a >>> 16;
        t = Math.imul(t, 0x21f0aaad);
        t = t ^ t >>> 15;
        t = Math.imul(t, 0x735a2d97);
        return ((t = t ^ t >>> 15) >>> 0) / 4294967296;
    }
}

function randomSeed() {
    return (Math.random() * (2 ** 32)) >>> 0;
}

const particleDescription = 
`
struct Particle
{
    x : f32,
    y : f32,
    species : f32,
    energy : f32,
    force_magnitude : f32,
}
`;

const speciesDescription =
`
struct Species
{
    color : vec4f,
}
`;

const cameraDescription =
`
struct Camera
{
    center : vec2f,
    extent : vec2f,
    pixelsPerUnit : f32,
}
`;

const simulationOptionsDescription =
`
struct SimulationOptions
{
    left : f32,
    right : f32,
    bottom : f32,
    top : f32,
    dt : f32,
    binSize : f32,
    speciesCount : f32,
	kernelsCount : f32,
	growthFuncsCount : f32,
    loopingBorders : f32,
    actionX : f32,
    actionY : f32,
    actionVX : f32,
    actionVY : f32,
    actionForce : f32,
    actionRadius : f32,
}

struct BinInfo
{
    gridSize : vec2i,
    binId : vec2i,
    binIndex : i32,
}

fn getBinInfo(position : vec2f, simulationOptions : SimulationOptions) -> BinInfo
{
    let gridSize = vec2i(
        i32(ceil((simulationOptions.right - simulationOptions.left) / simulationOptions.binSize)),
        i32(ceil((simulationOptions.top - simulationOptions.bottom) / simulationOptions.binSize)),
    );

    let binId = vec2i(
        clamp(i32(floor((position.x - simulationOptions.left) / simulationOptions.binSize)), 0, gridSize.x - 1),
        clamp(i32(floor((position.y - simulationOptions.bottom) / simulationOptions.binSize)), 0, gridSize.y - 1)
    );

    let binIndex = binId.y * gridSize.x + binId.x;

    return BinInfo(gridSize, binId, binIndex);
}
`;

const binFillSizeShader = 
`
${particleDescription}
${simulationOptionsDescription}

@group(0) @binding(0) var<storage, read> particles : array<Particle>;

@group(1) @binding(0) var<uniform> simulationOptions : SimulationOptions;

@group(2) @binding(0) var<storage, read_write> binSize : array<atomic<u32>>;

@compute @workgroup_size(64)
fn clearBinSize(@builtin(global_invocation_id) id : vec3u)
{
    if (id.x >= arrayLength(&binSize)) {
        return;
    }

    atomicStore(&binSize[id.x], 0u);
}

@compute @workgroup_size(64)
fn fillBinSize(@builtin(global_invocation_id) id : vec3u)
{
    if (id.x >= arrayLength(&particles)) {
        return;
    }

    let particle = particles[id.x];

    let binIndex = getBinInfo(vec2f(particle.x, particle.y), simulationOptions).binIndex;

    atomicAdd(&binSize[binIndex + 1], 1u);
}
`;

const binPrefixSumShader = 
`
@group(0) @binding(0) var<storage, read> source : array<u32>;
@group(0) @binding(1) var<storage, read_write> destination : array<u32>;
@group(0) @binding(2) var<uniform> stepSize : u32;

@compute @workgroup_size(64)
fn prefixSumStep(@builtin(global_invocation_id) id : vec3u)
{
    if (id.x >= arrayLength(&source)) {
        return;
    }

    if (id.x < stepSize) {
        destination[id.x] = source[id.x];
    } else {
        destination[id.x] = source[id.x - stepSize] + source[id.x];
    }
}
`;

const particleSortShader = 
`
${particleDescription}
${simulationOptionsDescription}

@group(0) @binding(0) var<storage, read> source : array<Particle>;
@group(0) @binding(1) var<storage, read_write> destination : array<Particle>;
@group(0) @binding(2) var<storage, read> binOffset : array<u32>;
@group(0) @binding(3) var<storage, read_write> binSize : array<atomic<u32>>;

@group(1) @binding(0) var<uniform> simulationOptions : SimulationOptions;

@compute @workgroup_size(64)
fn clearBinSize(@builtin(global_invocation_id) id : vec3u)
{
    if (id.x >= arrayLength(&binSize)) {
        return;
    }

    atomicStore(&binSize[id.x], 0u);
}

@compute @workgroup_size(64)
fn sortParticles(@builtin(global_invocation_id) id : vec3u)
{
    if (id.x >= arrayLength(&source)) {
        return;
    }

    let particle = source[id.x];

    let binIndex = getBinInfo(vec2f(particle.x, particle.y), simulationOptions).binIndex;

    let newParticleIndex = binOffset[binIndex] + atomicAdd(&binSize[binIndex], 1);
    destination[newParticleIndex] = particle;
}
`;

const particleComputeForcesShader = 
`
${particleDescription}
${simulationOptionsDescription}

@group(0) @binding(0) var<storage, read> particlesSource : array<Particle>;
@group(0) @binding(1) var<storage, read_write> particlesDestination : array<Particle>;
@group(0) @binding(2) var<storage, read> binOffset : array<u32>;
@group(0) @binding(3) var<storage, read> params_k : array<f32>;
@group(0) @binding(4) var<storage, read> params_g : array<f32>;
@group(0) @binding(5) var<storage, read> c_rep : array<f32>;

@group(1) @binding(0) var<uniform> simulationOptions : SimulationOptions;

@compute @workgroup_size(64)
fn computeForces(@builtin(global_invocation_id) id : vec3u)
{
    if (id.x >= arrayLength(&particlesSource)) {
        return;
    }

    var particle = particlesSource[id.x];
    let species = u32(particle.species);

    let binInfo = getBinInfo(vec2f(particle.x, particle.y), simulationOptions);

    let loopingBorders = simulationOptions.loopingBorders == 1.0;

    var binXMin = binInfo.binId.x - 1;
    var binYMin = binInfo.binId.y - 1;

    var binXMax = binInfo.binId.x + 1;
    var binYMax = binInfo.binId.y + 1;

    if (!loopingBorders) {
        binXMin = max(0, binXMin);
        binYMin = max(0, binYMin);
        binXMax = min(binInfo.gridSize.x - 1, binXMax);
        binYMax = min(binInfo.gridSize.y - 1, binYMax);
    }

    let width = simulationOptions.right - simulationOptions.left;
    let height = simulationOptions.top - simulationOptions.bottom;

    let particlePosition = vec2f(particle.x, particle.y);

	let speciesCount = u32(simulationOptions.speciesCount);
	let kernelsCount = u32(simulationOptions.kernelsCount);
	let growthFuncsCount = u32(simulationOptions.growthFuncsCount);
    var U = 0.0;
    var grad_U = vec2f(0.0, 0.0);
    var grad_R = vec2f(0.0, 0.0);
    let scale = 4.0;

    for (var binX = binXMin; binX <= binXMax; binX += 1) {
        for (var binY = binYMin; binY <= binYMax; binY += 1) {
            var realBinX = (binX + binInfo.gridSize.x) % binInfo.gridSize.x;
            var realBinY = (binY + binInfo.gridSize.y) % binInfo.gridSize.y;

            let binIndex = realBinY * binInfo.gridSize.x + realBinX;
            let binStart = binOffset[binIndex];
            let binEnd = binOffset[binIndex + 1];

            for (var j = binStart; j < binEnd; j += 1) {
                if (j == id.x) {
                    continue;
                }

                let other = particlesSource[j];
                let otherSpecies = u32(other.species);

                var diff = vec2f(other.x, other.y) - particlePosition;

                if (loopingBorders) {
                    if (abs(diff.x) >= width * 0.5) {
                        diff.x -= sign(diff.x) * width;
                    }

                    if (abs(diff.y) >= height * 0.5) {
                        diff.y -= sign(diff.y) * height;
                    }
                }

                let r = length(diff) / scale;
				let r_unit = diff / r;
				
				for (var k = 0u; k < kernelsCount; k += 1) {
					let mu_k = params_k[species * speciesCount * kernelsCount * 3 + otherSpecies * kernelsCount * 3 + k];
                    let sigma_k = params_k[species * speciesCount * kernelsCount * 3 + otherSpecies * kernelsCount * 3 + k + 1];
                    let w_k = params_k[species * speciesCount * kernelsCount * 3 + otherSpecies * kernelsCount * 3 + k + 2];
                    let r_mu_k = r - mu_k;
                    let sigma2_k = sigma_k * sigma_k;
                    let u_kernel = w_k * exp(-r_mu_k * r_mu_k / sigma2_k);
                    U += u_kernel; // Accumulate U

                    let dU_dr = -2.0 * u_kernel * r_mu_k / sigma2_k;
                    grad_U += dU_dr * r_unit; // Accumulate gradient of U
				}

                let this_c_rep = c_rep[species * speciesCount + otherSpecies];
                let d_rep = 1.0;
                let d_R = this_c_rep * max((d_rep - r) / d_rep, 0.0);
                grad_R += d_R * r_unit;
            }
        }
    }
    
    var dG_dU = 0.0;
    // let mu_g = 0.6;
    // let sigma_g = 0.15;
    for (var k = 0u; k < growthFuncsCount; k += 1) {
        let mu_g = params_g[species * growthFuncsCount * 2 + k];
        let sigma_g = params_g[species * growthFuncsCount * 2 + k + 1];
        // Calculate dG_dU for each growth function
        let sigma2_g = sigma_g * sigma_g;
        let U_mu_g = U - mu_g;
        dG_dU += 2 * U_mu_g / sigma2_g * exp(-U_mu_g * U_mu_g / sigma2_g); // Accumulate dG_dU
    }

    let grad_G = dG_dU * grad_U; // Calculate gradient of G

    let force = grad_G - grad_R;
    // let force = vec2f(0.0, 0.0);

    // Assume mass = 1
    particle.x += force.x * simulationOptions.dt;
    particle.y += force.y * simulationOptions.dt;
    particle.force_magnitude = length(force);
    particle.energy = U;

    particlesDestination[id.x] = particle;
}
`;

const particleAdvanceShader =
`
${particleDescription}
${simulationOptionsDescription}

@group(0) @binding(0) var<storage, read_write> particles : array<Particle>;

@group(1) @binding(0) var<uniform> simulationOptions : SimulationOptions;

@compute @workgroup_size(64)
fn particleAdvance(@builtin(global_invocation_id) id : vec3u)
{
    if (id.x >= arrayLength(&particles)) {
        return;
    }

    let width = simulationOptions.right - simulationOptions.left;
    let height = simulationOptions.top - simulationOptions.bottom;

    var particle = particles[id.x];

    var actionR = vec2f(particle.x, particle.y) - vec2f(simulationOptions.actionX, simulationOptions.actionY);
    if (simulationOptions.loopingBorders == 1.0) {
        if (abs(actionR.x) >= width * 0.5) {
            actionR.x -= sign(actionR.x) * width;
        }

        if (abs(actionR.y) >= height * 0.5) {
            actionR.y -= sign(actionR.y) * height;
        }
    }
    let actionFactor = simulationOptions.actionForce * exp(- dot(actionR, actionR) / (simulationOptions.actionRadius * simulationOptions.actionRadius));
    particle.x += simulationOptions.actionVX * actionFactor;
    particle.y += simulationOptions.actionVY * actionFactor;

    let loopingBorders = simulationOptions.loopingBorders == 1.0;

    if (loopingBorders) {
        if (particle.x < simulationOptions.left) {
            particle.x += width;
        }
    
        if (particle.x > simulationOptions.right) {
            particle.x -= width;
        }

        if (particle.y < simulationOptions.bottom) {
            particle.y += height;
        }
    
        if (particle.y > simulationOptions.top) {
            particle.y -= height;
        }
    } else {
        if (particle.x < simulationOptions.left) {
            particle.x = simulationOptions.left;
        }

        if (particle.x > simulationOptions.right) {
            particle.x = simulationOptions.right;
        }

        if (particle.y < simulationOptions.bottom) {
            particle.y = simulationOptions.bottom;
        }

        if (particle.y > simulationOptions.top) {
            particle.y = simulationOptions.top;
        }
    }

    particles[id.x] = particle;
}
`;

const particleRenderShader =
`
${particleDescription}
${speciesDescription}
${cameraDescription}

@group(0) @binding(0) var<storage, read> particles : array<Particle>;
@group(0) @binding(1) var<storage, read> species : array<Species>;

@group(1) @binding(0) var<uniform> camera : Camera;

struct CircleVertexOut
{
    @builtin(position) position : vec4f,
    @location(0) offset : vec2f,
    @location(1) color : vec4f,
}

const offsets = array<vec2f, 6>(
    vec2f(-1.0, -1.0),
    vec2f( 1.0, -1.0),
    vec2f(-1.0,  1.0),
    vec2f(-1.0,  1.0),
    vec2f( 1.0, -1.0),
    vec2f( 1.0,  1.0),
);

@vertex
fn vertexGlow(@builtin(vertex_index) id : u32) -> CircleVertexOut
{
    let particle = particles[id / 6u];
    let offset = offsets[id % 6u];
    let position = vec2f(particle.x, particle.y) + 12.0 * offset;
    return CircleVertexOut(
        vec4f((position - camera.center) / camera.extent, 0.0, 1.0),
        offset,
        species[u32(particle.species)].color
    );
}

@fragment
fn fragmentGlow(in : CircleVertexOut) -> @location(0) vec4f
{
    let l = length(in.offset);
    let alpha = exp(- 6.0 * l * l) / 64.0;
    return in.color * vec4f(1.0, 1.0, 1.0, alpha);
}

@vertex
fn vertexCircle(@builtin(vertex_index) id : u32) -> CircleVertexOut
{
    let particle = particles[id / 6u];
    let offset = offsets[id % 6u] * 1.5;
    let position = vec2f(particle.x, particle.y) + offset;
    return CircleVertexOut(
        vec4f((position - camera.center) / camera.extent, 0.0, 1.0),
        offset,
        species[u32(particle.species)].color
    );
}

@fragment
fn fragmentCircle(in : CircleVertexOut) -> @location(0) vec4f
{
    let alpha = clamp(camera.pixelsPerUnit - length(in.offset) * camera.pixelsPerUnit + 0.5, 0.0, 1.0);
    return in.color * vec4f(1.0, 1.0, 1.0, alpha);
}

@vertex
fn vertexPoint(@builtin(vertex_index) id : u32) -> CircleVertexOut
{
    let particle = particles[id / 6u];
    let offset = 2.0 * offsets[id % 6u] / camera.pixelsPerUnit;
    let position = vec2f(particle.x, particle.y) + offset;
    return CircleVertexOut(
        vec4f((position - camera.center) / camera.extent, 0.0, 1.0),
        offset,
        species[u32(particle.species)].color
    );
}

const PI = 3.1415926535;

@fragment
fn fragmentPoint(in : CircleVertexOut) -> @location(0) vec4f
{
    let d = max(vec2(0.0), min(in.offset * camera.pixelsPerUnit + 0.5, vec2(camera.pixelsPerUnit)) - max(in.offset * camera.pixelsPerUnit - 0.5, - vec2(camera.pixelsPerUnit)));
    let alpha = (PI / 4.0) * d.x * d.y;
    return vec4f(in.color.rgb, in.color.a * alpha);
}
`;

const composeShader =
`
@group(0) @binding(0) var hdrTexture : texture_2d<f32>;
@group(0) @binding(1) var blueNoiseTexture : texture_2d<f32>;

const vertices = array<vec2f, 3>(
    vec2f(-1.0, -1.0),
    vec2f( 3.0, -1.0),
    vec2f(-1.0,  3.0),
);

struct VertexOut
{
    @builtin(position) position : vec4f,
    @location(0) texcoord : vec2f,
}

@vertex
fn vertexMain(@builtin(vertex_index) id : u32) -> VertexOut
{
    let vertex = vertices[id];
    return VertexOut(
        vec4f(vertex, 0.0, 1.0),
        vertex * 0.5 + vec2f(0.5)
    );
}

fn acesTonemap(x : vec3f) -> vec3f
{
    let a = 2.51;
    let b = 0.03;
    let c = 2.43;
    let d = 0.59;
    let e = 0.14;
    return clamp((x*(a*x+b))/(x*(c*x+d)+e), vec3f(0.0), vec3f(1.0));
}

fn maxTonemap(x : vec3f) -> vec3f
{
    let m = max(1.0, max(x.r, max(x.g, x.b)));
    return x / m;
}

fn uncharted2TonemapImpl(x : vec3f) -> vec3f
{
    let A = 0.15;
    let B = 0.50;
    let C = 0.10;
    let D = 0.20;
    let E = 0.02;
    let F = 0.30;

    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

fn uncharted2Tonemap(x : vec3f) -> vec3f
{
    let exposure = 5.0;
    let white = 10.0;
    return uncharted2TonemapImpl(x * exposure) / uncharted2TonemapImpl(vec3f(white));
}

fn agxTonemap(x : vec3f) -> vec3f
{
    const M1 = mat3x3f(0.842, 0.0423, 0.0424, 0.0784, 0.878, 0.0784, 0.0792, 0.0792, 0.879);
    const M2 = mat3x3f(1.2, -0.053, -0.053, -0.1, 1.15, -0.1, -0.1, -0.1, 1.15);
    const c1 = 12.47393;
    const c2 = 16.5;

    var result = x * 0.5;
    result = M1 * result;
    result = clamp((log2(result) + c1) / c2, vec3f(0.0), vec3f(1.0));
    result = 0.5 + 0.5 * sin(((-3.11 * result + 6.42) * result - 0.378) * result - 1.44);
    result = M2 * result;

    return result;
}

fn dither(x : vec3f, n : f32) -> vec3f
{
    let c = x * 255.0;
    let c0 = floor(c);
    let c1 = c0 + vec3f(1.0);
    let dc = c - c0;

    var r = c0;
    if (dc.r > n) { r.r = c1.r; }
    if (dc.g > n) { r.g = c1.g; }
    if (dc.b > n) { r.b = c1.b; }

    return r / 255.0;
}

@fragment
fn fragmentMain(in : VertexOut) -> @location(0) vec4f
{
    var sample = textureLoad(hdrTexture, vec2i(in.position.xy), 0); 
    let noise = textureLoad(blueNoiseTexture, vec2u(in.position.xy) % textureDimensions(blueNoiseTexture), 0).r;

    var color = sample.rgb;
    color = acesTonemap(color);
    color = pow(color, vec3f(1.0 / 2.2));
    color = dither(color, noise);

    return vec4f(color, 1.0);
}
`;

const audioShader = `
${particleDescription}
${speciesDescription}
${cameraDescription}
${simulationOptionsDescription}

override WORKGROUP_SIZE: u32 = 256;
override SAMPLING_RATE: f32 = 44100.0;
struct TimeInfo {
    // time since song start in seconds
    offset: f32,
}
@group(0) @binding(0) var<uniform> time_info: TimeInfo;
@group(0) @binding(1) var<storage, read_write> song_chunk: array<vec2<f32>>; // 2 channel pcm data

@group(1) @binding(0) var<storage, read> particlesSource : array<Particle>;
@group(1) @binding(2) var<storage, read> binOffset : array<u32>;

@group(2) @binding(0) var<uniform> simulationOptions : SimulationOptions;

@group(3) @binding(0) var<uniform> camera : Camera;

@compute
@workgroup_size(WORKGROUP_SIZE)
fn synthezise(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let sample = global_id.x;
    if sample >= arrayLength(&song_chunk) {
        return;
    }
    let t = f32(sample) / SAMPLING_RATE;
    song_chunk[sample] = song(time_info.offset + t);
}

const PI: f32 = 3.141592654;
const TAU: f32 = 6.283185307179586476925286766559;

fn song(time: f32) -> vec2<f32> {

    let binInfo = getBinInfo(camera.center, simulationOptions);

    let loopingBorders = simulationOptions.loopingBorders == 1.0;

    var binXMin = binInfo.binId.x - 1;
    var binYMin = binInfo.binId.y - 1;

    var binXMax = binInfo.binId.x + 1;
    var binYMax = binInfo.binId.y + 1;

    if (!loopingBorders) {
        binXMin = max(0, binXMin);
        binYMin = max(0, binYMin);
        binXMax = min(binInfo.gridSize.x - 1, binXMax);
        binYMax = min(binInfo.gridSize.y - 1, binYMax);
    }

    let width = simulationOptions.right - simulationOptions.left;
    let height = simulationOptions.top - simulationOptions.bottom;

	let speciesCount = u32(simulationOptions.speciesCount);

    let c_freq = 440.0;
    let m_freq = 0.1;

    var sig = vec2f(0.0, 0.0);
    for (var binX = binXMin; binX <= binXMax; binX += 1) {
        for (var binY = binYMin; binY <= binYMax; binY += 1) {
            var realBinX = (binX + binInfo.gridSize.x) % binInfo.gridSize.x;
            var realBinY = (binY + binInfo.gridSize.y) % binInfo.gridSize.y;

            let binIndex = realBinY * binInfo.gridSize.x + realBinX;
            let binStart = binOffset[binIndex];
            let binEnd = binOffset[binIndex + 1];

            for (var j = binStart; j < binEnd; j += 1) {

                let other = particlesSource[j];
                let otherSpecies = u32(other.species);

                let leftEar = camera.center - vec2f(camera.extent.x / 2, 0.0);
                let rightEar = camera.center + vec2f(camera.extent.x / 2, 0.0);
                var leftDist = length(vec2f(other.x, other.y) - leftEar) / camera.extent.x;
                var rightDist = length(vec2f(other.x, other.y) - rightEar) / camera.extent.x;

                // TODO skip for particles over maxForceRadius to ensure audio isn't biased by binning

                // particles that are closer are louder
                // particles that are further away get lowpassed
                // particles moving faster are louder and have more high frequencies
                // particles with more energy have a different timbre
                var p_sig = 0.0;
                // for (var k = 1u; k < 6u; k++) {
                //     p_sig += other.force_magnitude * sin(TAU * time * f32(k) * c_freq + other.energy * sin(TAU * time * (other.species + 1) * m_freq));
                // }
                p_sig = 0.01 * other.force_magnitude * sin(TAU * time * other.energy * 1000.0);

                // pan the signal based on the particle's position wrt the camera center
                sig += vec2f(
                    p_sig / leftDist,
                    p_sig / rightDist
                );
            }
        }
    }

    // x = left channel, y = right channel
    return sig;
}
`;

var canvas;
var context;
var surfaceFormat;
var device;

const hdrFormat = 'rgba16float';

var timestampQuerySupported = true;

// TODO make sure this lines up with max interaction distance 
const maxForceRadius = 32.0;

var speciesCount = 3;
var particleCount = 16 * 1024;
var simulationBox = [[-4, 4], [-4, 4]];
var loopingBorders = false;
var gridSize = [Math.ceil((simulationBox[0][1] - simulationBox[0][0]) / maxForceRadius), Math.ceil((simulationBox[1][1] - simulationBox[1][0]) / maxForceRadius)];
var binCount = gridSize[0] * gridSize[1];
var prefixSumIterations = Math.ceil(Math.ceil(Math.log2(binCount + 1)) / 2) * 2;

var customRules = false;

var currentSystemDescription;

var speciesBuffer;
var params_k_Buffer;
var params_g_Buffer;
var c_rep_Buffer;
var particleBuffer;
var particleTempBuffer;
var binOffsetBuffer;
var binOffsetTempBuffer;
var binPrefixSumStepSizeBuffer;
var cameraBuffer;
var simulationOptionsBuffer;

var blueNoiseTexture;
var blueNoiseTextureView;
var hdrTexture;
var hdrTextureView;

var particleBufferBindGroupLayout;
var particleBufferReadOnlyBindGroupLayout;
var cameraBindGroupLayout;
var simulationOptionsBindGroupLayout;
var binFillSizeBindGroupLayout;
var binPrefixSumBindGroupLayout;
var particleSortBindGroupLayout;
var particleComputeForcesBindGroupLayout;
var composeBindGroupLayout;

var particleBufferBindGroup;
var particleBufferReadOnlyBindGroup;
var binFillSizeBindGroup;
var binPrefixSumBindGroup = [null, null];
var particleSortBindGroup;
var particleComputeForcesBindGroup;
var cameraBindGroup;
var simulationOptionsBindGroup;
var composeBindGroup;

var binClearSizePipeline;
var binFillSizePipeline;
var binPrefixSumPipeline;
var particleSortClearSizePipeline;
var particleSortPipeline;
var particleComputeForcesPipeline;
var particleAdvancePipeline;
var particleRenderGlowPipeline;
var particleRenderPipeline;
var particleRenderPointPipeline;
var composePipeline;

var cameraCenter = [0.0, 0.0];
var cameraExtentX = simulationBox[0][1];
var cameraExtentY = simulationBox[1][1];
var cameraExtentXTarget = simulationBox[0][1];

var zoomAnchor = null;

var lastFrameTimestamp = window.performance.now() / 1000.0;

var mouseDrag = null;
var actionPoint = null;
var actionDrag = null;

const activeTouches = new Map();
var lastTouchTime = null;
var isDoubleTap = false;

var frameID = 0;
var framesInFlight = 0;

var paused = false;
var toolsPanelShown = true;
var debugPanelShown = false;

var freeQueryHelpers = [];

const chunkDurationSeconds = 0.1;
const numChannels = 2;
const workGroupSize = 256;
const maxBufferedChunks = 2;

var timeInfoBuffer;
var songChunkBuffer;

var audioPipeline;
var audioBindGroup;
var audioBindGroupLayout;
var audioRingBuffer;

var chunkNumSamplesPerChannel;
var chunkNumSamples;
var chunkBufferSize;
var chunkBuffer;

var audioCtx;
var audioPaused;

// state tracking
const startTime = performance.now() / 1000.0;
let nextChunkOffset = 0.0;

function QueryHelper()
{
    this.querySet = device.createQuerySet({
        count: 16,
        type: 'timestamp',
    });

    this.resolveBuffer = device.createBuffer({
        size: 8 * 16,
        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE,
    });

    this.readBuffer = device.createBuffer({
        size: 8 * 16,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
    });

    this.currentIndex = 0;
    this.start = () => this.currentIndex = 0;
    this.next = () => {
        const result = {
            querySet: this.querySet,
            beginningOfPassWriteIndex: this.currentIndex,
            endOfPassWriteIndex: this.currentIndex + 1,
        };
        this.currentIndex += 2;
        return result;
    };
}

class AudioRingBuffer {
    constructor(bufferCount = 4) {
        this.storageBuffers = [];  // GPU storage buffers
        this.mapBuffers = [];      // CPU-readable buffers
        this.writeIndex = 0;
        this.readIndex = 0;
        this.size = bufferCount;
        
        // Pre-create ALL buffers upfront
        for (let i = 0; i < bufferCount; i++) {
            this.storageBuffers.push(device.createBuffer({
                size: chunkBufferSize,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
            }));
            
            this.mapBuffers.push(device.createBuffer({
                size: chunkBufferSize,
                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
            }));
        }
    }
    
    // Get next buffer for GPU writing
    getCurrentWriteBuffers() {
        const index = this.writeIndex % this.size;
        return {
            storage: this.storageBuffers[index],
            map: this.mapBuffers[index]
        };
    }
    
    // Move to next buffer set
    advanceWrite() {
        this.writeIndex++;
    }
}

function formatExecutionTime(x) {
    var result = (Number(x) / 1000000).toFixed(2);
    while (result.length < 5) {
        result = " " + result;
    }
    return result + " ms";
}

function redraw()
{
    if (framesInFlight > 2) {
        requestAnimationFrame(redraw);
        return;
    }

    const now = window.performance.now() / 1000.0;

    const dt = now - lastFrameTimestamp;
    lastFrameTimestamp = now;

    const aspectRatio = canvas.width / canvas.height;
    const cameraExtentXDelta = (cameraExtentXTarget - cameraExtentX) * (- Math.expm1(- 20 * dt));

    cameraExtentX += cameraExtentXDelta;
    cameraExtentY = cameraExtentX / aspectRatio;

    if (zoomAnchor) {
        cameraCenter[0] -= cameraExtentXDelta * zoomAnchor[0];
        cameraCenter[1] -= cameraExtentXDelta * zoomAnchor[1] / aspectRatio;
    }

    const pixelsPerUnit = canvas.width / (2.0 * cameraExtentX);

    const toolsPanel = document.getElementById("toolsPanel");
    var toolsPanelAlpha = Number(toolsPanel.style.opacity);
    toolsPanelAlpha += ((toolsPanelShown ? 1.0 : 0.0) - toolsPanelAlpha) * (- Math.expm1(- 20 * dt));
    toolsPanel.style.opacity = toolsPanelAlpha;
    toolsPanel.style.visibility = (toolsPanelAlpha < 0.01) ? "hidden" : "visible";

    const debugPanel = document.getElementById("debugPanel");
    var debugPanelAlpha = Number(debugPanel.style.opacity);
    debugPanelAlpha += ((debugPanelShown ? 1.0 : 0.0) - debugPanelAlpha) * (- Math.expm1(- 20 * dt));
    debugPanel.style.opacity = debugPanelAlpha;
    debugPanel.style.visibility = (debugPanelAlpha < 0.01) ? "hidden" : "visible";

    const simDt = 0.1;//Math.min(0.025, dt);

    const actionX = actionPoint ? cameraCenter[0] + cameraExtentX * (2.0 * actionPoint[0] / canvas.width - 1.0) : 0.0;
    const actionY = actionPoint ? cameraCenter[1] + cameraExtentY * (1.0 - 2.0 * actionPoint[1] / canvas.height) : 0.0;
    const actionVX = actionDrag ? cameraExtentX * (2.0 * actionDrag[0] / canvas.width) : 0.0;
    const actionVY = actionDrag ? cameraExtentY * (- 2.0 * actionDrag[1] / canvas.height) : 0.0;
    const actionForce = actionPoint ? 20.0 : 0.0;
    const actionRadius = cameraExtentX / 16.0;

    actionDrag = [0.0, 0.0];

    device.queue.writeBuffer(simulationOptionsBuffer, 0, new Float32Array([simulationBox[0][0], simulationBox[0][1], simulationBox[1][0], simulationBox[1][1], simDt, maxForceRadius, speciesCount, kernelsCount, growthFuncsCount, loopingBorders ? 1.0 : 0.0, actionX, actionY, actionVX, actionVY, actionForce, actionRadius]));
    device.queue.writeBuffer(cameraBuffer, 0, new Float32Array([cameraCenter[0], cameraCenter[1], cameraExtentX, cameraExtentY, pixelsPerUnit]));

    var queryHelper;
    if (timestampQuerySupported) {
        if (freeQueryHelpers.length > 0) {
            queryHelper = freeQueryHelpers.pop();
        } else {
            queryHelper = new QueryHelper();
        }
        queryHelper.start();
    }
 
    const encoder = device.createCommandEncoder({});

    if (!paused) {
        encoder.copyBufferToBuffer(particleBuffer, 0, particleTempBuffer, 0, particleBuffer.size);

        const binningComputePass = encoder.beginComputePass({
            ...(timestampQuerySupported) && {timestampWrites: queryHelper.next()},
        });

        binningComputePass.setBindGroup(0, particleBufferReadOnlyBindGroup);
        binningComputePass.setBindGroup(1, simulationOptionsBindGroup);
        binningComputePass.setBindGroup(2, binFillSizeBindGroup);
        binningComputePass.setPipeline(binClearSizePipeline);
        binningComputePass.dispatchWorkgroups(Math.ceil((binCount + 1) / 64));
        binningComputePass.setPipeline(binFillSizePipeline);
        binningComputePass.dispatchWorkgroups(Math.ceil(particleCount / 64));

        binningComputePass.setPipeline(binPrefixSumPipeline);
        for (var i = 0; i < prefixSumIterations; ++i) {
            binningComputePass.setBindGroup(0, binPrefixSumBindGroup[i % 2], [i * 256]);
            binningComputePass.dispatchWorkgroups(Math.ceil((binCount + 1) / 64));
        }

        binningComputePass.setBindGroup(0, particleSortBindGroup);
        binningComputePass.setPipeline(particleSortClearSizePipeline);
        binningComputePass.dispatchWorkgroups(Math.ceil((binCount + 1) / 64));
        binningComputePass.setPipeline(particleSortPipeline);
        binningComputePass.dispatchWorkgroups(Math.ceil(particleCount / 64));

        binningComputePass.end();

        const forcesComputePass = encoder.beginComputePass({
            ...(timestampQuerySupported) && {timestampWrites: queryHelper.next()},
        });

        forcesComputePass.setBindGroup(0, particleComputeForcesBindGroup);
        forcesComputePass.setBindGroup(1, simulationOptionsBindGroup);
        forcesComputePass.setPipeline(particleComputeForcesPipeline);
        forcesComputePass.dispatchWorkgroups(Math.ceil(particleCount / 64));

        forcesComputePass.end();

        const advanceComputePass = encoder.beginComputePass({
            ...(timestampQuerySupported) && {timestampWrites: queryHelper.next()},
        });

        advanceComputePass.setBindGroup(0, particleBufferBindGroup);
        advanceComputePass.setBindGroup(1, simulationOptionsBindGroup);
        advanceComputePass.setPipeline(particleAdvancePipeline);
        advanceComputePass.dispatchWorkgroups(Math.ceil(particleCount / 64));

        advanceComputePass.end();
    }
 
    const hdrRenderPass = encoder.beginRenderPass({
        colorAttachments: [
            {
                view: hdrTextureView,
                clearValue: [0.001, 0.001, 0.001, 0.0],
                loadOp: 'clear',
                storeOp: 'store',
            },
        ],
        ...(timestampQuerySupported) && {timestampWrites: queryHelper.next()},
        // timestampWrites: [
        //     {
        //         location: 'beginning',
        //         querySet: queryHelper.querySet,
        //         queryIndex: 6,
        //     },
        //     {
        //         location: 'end',
        //         querySet: queryHelper.querySet,
        //         queryIndex: 7,
        //     },
        // ],
    });
    hdrRenderPass.setBindGroup(0, particleBufferReadOnlyBindGroup);
    hdrRenderPass.setBindGroup(1, cameraBindGroup);
    hdrRenderPass.setPipeline(particleRenderGlowPipeline);
    hdrRenderPass.draw(particleCount * 6);
    if (pixelsPerUnit < 1.0) {
        hdrRenderPass.setPipeline(particleRenderPointPipeline);
        hdrRenderPass.draw(particleCount * 6);
    } else {
        hdrRenderPass.setPipeline(particleRenderPipeline);
        hdrRenderPass.draw(particleCount * 6);
    }
    hdrRenderPass.end();
 
    const composeRenderPass = encoder.beginRenderPass({
        colorAttachments: [
            {
                view: context.getCurrentTexture().createView(),
                clearValue: [0, 0, 0, 0],
                loadOp: 'clear',
                storeOp: 'store',
            },
        ],
        ...(timestampQuerySupported) && {timestampWrites: queryHelper.next()},
    });
    composeRenderPass.setBindGroup(0, composeBindGroup);
    composeRenderPass.setPipeline(composePipeline);
    composeRenderPass.draw(3);
    composeRenderPass.end();

    if (timestampQuerySupported) {
        encoder.resolveQuerySet(queryHelper.querySet, 0, queryHelper.querySet.count, queryHelper.resolveBuffer, 0);
        encoder.copyBufferToBuffer(queryHelper.resolveBuffer, 0, queryHelper.readBuffer, 0, queryHelper.resolveBuffer.size);
    }
 
    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

    if (timestampQuerySupported) {
        queryHelper.readBuffer.mapAsync(GPUMapMode.READ).then(() => {
            const values = new BigUint64Array(queryHelper.readBuffer.getMappedRange());
            var debugText = "";
            debugText += "Binning: " + (paused ? " -------" : formatExecutionTime(values[1] - values[0])) + "\n";
            debugText += "Forces:  " + (paused ? " -------" : formatExecutionTime(values[3] - values[2])) + "\n";
            debugText += "Advance: " + (paused ? " -------" : formatExecutionTime(values[5] - values[4])) + "\n";
            debugText += "Render:  " + formatExecutionTime(values[7] - values[6]) + "\n";
            debugText += "Compose: " + formatExecutionTime(values[9] - values[8]) + "\n";
            document.getElementById("debugInfo").innerText = debugText;
            queryHelper.readBuffer.unmap();
            freeQueryHelpers.push(queryHelper);
        }).catch((error) => {
            console.error("Failed to map query buffer:", error);
            // Clean up the failed QueryHelper
            queryHelper.querySet.destroy();
            queryHelper.resolveBuffer.destroy();
            queryHelper.readBuffer.destroy();
        });
    }

    ++framesInFlight;

    device.queue.onSubmittedWorkDone().then(() => { --framesInFlight; });

    ++frameID;

    requestAnimationFrame(redraw);
}

// create sound data on the GPU, read back to CPU and schedule for playback
async function createAudioChunk() {
    if (paused || audioPaused || !audioCtx || audioCtx.state !== 'running') {
        console.log('paused, not creating song chunk');
        setTimeout(createAudioChunk, 100); // Check again in 100ms
        return;
    }

    // if we've already scheduled `maxBufferedChunks` of sound data for playback, reschedule sound data creation for later
    const bufferedSeconds = (startTime + nextChunkOffset) - (performance.now() / 1000.0);
    const numBufferedChunks = Math.floor(bufferedSeconds / chunkDurationSeconds);
    if (numBufferedChunks > maxBufferedChunks) {
        const timeout = chunkDurationSeconds * 0.9;
        setTimeout(createAudioChunk, timeout * 1000.0);
        console.log(`buffered chunks ${numBufferedChunks} (${bufferedSeconds} seconds), next chunk creation starts in ${timeout} seconds`);
        return;
    }

    // update uniform buffer: set the new chunk's offset in seconds from t = 0
    console.log('writing nextChunkOffset', nextChunkOffset);
    device.queue.writeBuffer(timeInfoBuffer, 0, new Float32Array([nextChunkOffset]));

    const commandEncoder = device.createCommandEncoder();

    // encode compute pass, i.e., sound chunk creation
    const pass = commandEncoder.beginComputePass();
    pass.setPipeline(audioPipeline);
    pass.setBindGroup(0, audioBindGroup);
    pass.setBindGroup(1, particleComputeForcesBindGroup);
    pass.setBindGroup(2, simulationOptionsBindGroup);
    pass.setBindGroup(3, cameraBindGroup);
    pass.dispatchWorkgroups(
        Math.ceil(chunkNumSamplesPerChannel / workGroupSize)
    );
    pass.end();

    // copy sound chunk to map buffer
    commandEncoder.copyBufferToBuffer(chunkBuffer, 0, chunkMapBuffer, 0, chunkBufferSize);

    device.queue.submit([commandEncoder.finish()]);

    // after submitting(!) chunk creation & copy commands, map chunkMapBuffer's memory to CPU memory for reading
    // Note: a mapped buffer is not allowed to be used in a command encoder.
    // To avoid an illegal use of the map buffer in a command encoder (i.e., when copying the data from the storage buffer),
    // we wait for the buffer's memory to be mapped.
    // In this case, this is okay, because we have a couple of seconds of sound data cached in the audio context's destination,
    // so we can easily afford to wait for the GPU commands to finish and the buffer to be mapped.
    // However, doing this within the render loop of a real-time renderer is usually a bad idea, since it forces a CPU-GPU sync.
    // In such cases, it might be a good idea to have a ring buffer of map-buffers to not use the same map buffer in each frame.
    await chunkMapBuffer.mapAsync(GPUMapMode.READ, 0, chunkBufferSize);

    // when the buffer's memory is mapped, copy it to a JavaScript array and unmap the buffer
    const chunkData = new Float32Array(chunkNumSamples);
    chunkData.set(new Float32Array(chunkMapBuffer.getMappedRange()));
    chunkMapBuffer.unmap();

    // copy chunk data to audio buffer
    const audioBuffer = audioCtx.createBuffer(
        numChannels,
        chunkNumSamplesPerChannel,
        audioCtx.sampleRate
    );
    
    const channels = [];
    for (let i = 0; i < numChannels; ++i) {
        channels.push(audioBuffer.getChannelData(i));
    }

    for (let i = 0; i < audioBuffer.length; ++i) {
        for (const [offset, channel] of channels.entries()) {
            channel[i] = chunkData[i * numChannels + offset];
        }
    }

    // create new audio source from audio buffer and schedule for execution
    const audioSource = audioCtx.createBufferSource();
    audioSource.buffer = audioBuffer;
    audioSource.connect(audioCtx.destination);
    // (there is some issue with the second chunk's offset - no idea why, music's hard I guess)
    audioSource.start(nextChunkOffset);

    console.log(`created new chunk, starts at ${startTime + nextChunkOffset}`);

    // schedule next chunk creation
    nextChunkOffset += audioSource.buffer.duration;
    await createAudioChunk();
}

function centerView()
{
    cameraCenter = [0.0, 0.0];
    zoomAnchor = null;

    const aspectRatio = document.body.clientWidth / document.body.clientHeight;

    if ((simulationBox[0][1] - simulationBox[0][0]) / (simulationBox[1][1] - simulationBox[1][0]) > aspectRatio)
        cameraExtentXTarget = simulationBox[0][1];
    else
        cameraExtentXTarget = simulationBox[1][1] * aspectRatio;
}

function reloadParameters(systemDescription)
{
    const speciesCount = systemDescription.species.length;
    const kernelsCount = systemDescription.kernelsCount;
    const growthFuncsCount = systemDescription.growthFuncsCount;
    const params_k = new Float32Array(speciesCount * speciesCount * kernelsCount * 3);
    const params_g = new Float32Array(speciesCount * growthFuncsCount * 2);
    const c_rep = new Float32Array(speciesCount * speciesCount);
    for (var i = 0; i < speciesCount; ++i)
    {
        for (var j = 0; j < speciesCount; ++j)
        {
            c_rep[i * speciesCount + j] = systemDescription.species[i].c_rep[j];
            for (var k = 0; k < kernelsCount; ++k)
            {
                params_k[i * speciesCount * kernelsCount * 3 + j * kernelsCount * 3 + k] = systemDescription.species[i].mu_k[j * kernelsCount + k];
                params_k[i * speciesCount * kernelsCount * 3 + j * kernelsCount * 3 + k + 1] = systemDescription.species[i].sigma_k[j * kernelsCount + k];
                params_k[i * speciesCount * kernelsCount * 3 + j * kernelsCount * 3 + k + 2] = systemDescription.species[i].w_k[j * kernelsCount + k];
            }
        }
        for (var k = 0; k < growthFuncsCount; ++k)
        {
            params_g[i * growthFuncsCount * 2 + k] = systemDescription.species[i].mu_g[k];
            params_g[i * growthFuncsCount * 2 + k + 1] = systemDescription.species[i].sigma_g[k];
        }
    }
    
    device.queue.writeBuffer(params_k_Buffer, 0, params_k);
    device.queue.writeBuffer(params_g_Buffer, 0, params_g);
    device.queue.writeBuffer(c_rep_Buffer, 0, c_rep);
}

function cleanupQueryHelpers() {
    // Clean up all free query helpers
    while (freeQueryHelpers.length > 0) {
        const helper = freeQueryHelpers.pop();
        helper.querySet.destroy();
        helper.resolveBuffer.destroy();
        helper.readBuffer.destroy();
    }
}


function cleanupBuffers() {
    cleanupQueryHelpers();

    // Destroy all existing buffers
    if (speciesBuffer) speciesBuffer.destroy();
    if (params_k_Buffer) params_k_Buffer.destroy();
    if (params_g_Buffer) params_g_Buffer.destroy();
    if (c_rep_Buffer) c_rep_Buffer.destroy();
    if (particleBuffer) particleBuffer.destroy();
    if (particleTempBuffer) particleTempBuffer.destroy();
    if (binOffsetBuffer) binOffsetBuffer.destroy();
    if (binOffsetTempBuffer) binOffsetTempBuffer.destroy();
    if (binPrefixSumStepSizeBuffer) binPrefixSumStepSizeBuffer.destroy();
}


function loadSystem(systemDescription)
{
    cleanupBuffers();

    currentSystemDescription = systemDescription;

    particleCount = systemDescription.particleCount;
    speciesCount = systemDescription.species.length;
    kernelsCount = systemDescription.kernelsCount;
    growthFuncsCount = systemDescription.growthFuncsCount;

    if (systemDescription.loopingBorders == undefined)
        systemDescription.loopingBorders = false;

    loopingBorders = systemDescription.loopingBorders;

    customRules = false;

    const W = Math.round(systemDescription.simulationSize[0] / 64) * 32;
    const H = Math.round(systemDescription.simulationSize[1] / 64) * 32;

    simulationBox = [[-W, W], [-H, H]];

    document.getElementById("particleCountSlider").value = Math.round(Math.log2(particleCount));
    document.getElementById("particleCountText").innerText = `${particleCount} particles`;
    document.getElementById("speciesCountSlider").value = speciesCount;
    document.getElementById("speciesCountText").innerText = `${speciesCount} particle types`;
    document.getElementById("kernelsCountSlider").value = kernelsCount;
    document.getElementById("kernelsCountText").innerText = `${kernelsCount} kernels`;
    document.getElementById("growthFuncsCountSlider").value = growthFuncsCount;
    document.getElementById("growthFuncsCountText").innerText = `${growthFuncsCount} growth functions`;
    document.getElementById("simulationWidthSlider").value = Math.round(systemDescription.simulationSize[0] / 64);
    document.getElementById("simulationWidthText").innerText = `Width: ${2 * W}`;
    document.getElementById("simulationHeightSlider").value = Math.round(systemDescription.simulationSize[1] / 64);
    document.getElementById("simulationHeightText").innerText = `Height: ${2 * H}`;
    document.getElementById("loopingBorders").checked = loopingBorders;

    gridSize = [Math.ceil(systemDescription.simulationSize[0] / maxForceRadius), Math.ceil(systemDescription.simulationSize[1] / maxForceRadius)];
    binCount = gridSize[0] * gridSize[1];
    prefixSumIterations = Math.ceil(Math.ceil(Math.log2(binCount + 1)) / 2) * 2;

    const species = new Float32Array(speciesCount * 4);
    for (var i = 0; i < speciesCount; ++i)
    {
        species[4 * i + 0] = systemDescription.species[i].color[0];
        species[4 * i + 1] = systemDescription.species[i].color[1];
        species[4 * i + 2] = systemDescription.species[i].color[2];
        species[4 * i + 3] = 1.0;
    }

    speciesBuffer = device.createBuffer({
        size: speciesCount * 16,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,
        label: "speciesBuffer",
    });
    
    device.queue.writeBuffer(speciesBuffer, 0, species);

    params_k_Buffer = device.createBuffer({
        size: speciesCount * speciesCount * kernelsCount * 3 * 4,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,
        label: "params_k_Buffer",
    });

    params_g_Buffer = device.createBuffer({
        size: speciesCount * growthFuncsCount * 2 * 4,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,
        label: "params_g_Buffer",
    });

    c_rep_Buffer = device.createBuffer({
        size: speciesCount * speciesCount * 4,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,
        label: "c_rep_Buffer",
    });

    reloadParameters(systemDescription);

    let numParticleAttributes = 5; // x, y, species, force_magnitude, energy
    const initialParticles = new Float32Array(particleCount * numParticleAttributes);

    for (var i = 0; i < speciesCount; ++i)
        if (systemDescription.species[i].spawnWeight == undefined)
            systemDescription.species[i].spawnWeight = 1.0;

    var speciesWeightSum = 0.0;
    for (var i = 0; i < speciesCount; ++i)
        speciesWeightSum += systemDescription.species[i].spawnWeight;

    for (var i = 0; i < particleCount; ++i)
    {
        var speciesPick = Math.random() * speciesWeightSum;

        var speciesId = speciesCount - 1;
        for (var j = 0; j < speciesCount; ++j) {
            if (speciesPick < systemDescription.species[j].spawnWeight) {
                speciesId = j;
                break;
            }
            speciesPick -= systemDescription.species[j].spawnWeight;
        }

        initialParticles[numParticleAttributes * i + 0] = simulationBox[0][0] + Math.random() * (simulationBox[0][1] - simulationBox[0][0]);
        initialParticles[numParticleAttributes * i + 1] = simulationBox[1][0] + Math.random() * (simulationBox[1][1] - simulationBox[1][0]);
        initialParticles[numParticleAttributes * i + 2] = speciesId;
    }

    particleBuffer = device.createBuffer({
        size: particleCount * numParticleAttributes * 4, // 5 floats per particle: x, y, species, force_magnitude, energy
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,
        label: "particleBuffer",
    });

    device.queue.writeBuffer(particleBuffer, 0, initialParticles);

    particleTempBuffer = device.createBuffer({
        size: particleBuffer.size,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
        label: "particleTempBuffer",
    });

    binOffsetBuffer = device.createBuffer({
        size: (binCount + 1) * 4,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
        label: "binOffsetBuffer",
    });

    binOffsetTempBuffer = device.createBuffer({
        size: (binCount + 1) * 4,
        usage: GPUBufferUsage.STORAGE,
        label: "binOffsetTempBuffer",
    });

    const binPrefixSumStepSize = new Uint32Array(prefixSumIterations * 64);
    for (var i = 0; i < prefixSumIterations; ++i)
        binPrefixSumStepSize[i * 64] = Math.pow(2, i);

    binPrefixSumStepSizeBuffer = device.createBuffer({
        size: prefixSumIterations * 256,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
        label: "binPrefixSumStepSizeBuffer",
    });

    device.queue.writeBuffer(binPrefixSumStepSizeBuffer, 0, binPrefixSumStepSize);

    particleBufferBindGroup = device.createBindGroup({
        label: "particleBufferBindGroup",
        layout: particleBufferBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: particleBuffer,
                },
            }
        ],
    });

    particleBufferReadOnlyBindGroup = device.createBindGroup({
        label: "particleBufferReadOnlyBindGroup",
        layout: particleBufferReadOnlyBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: particleBuffer,
                },
            },
            {
                binding: 1,
                resource: {
                    buffer: speciesBuffer,
                },
            },
        ],
    });

    binFillSizeBindGroup = device.createBindGroup({
        label: "binFillSizeBindGroup",
        layout: binFillSizeBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: binOffsetBuffer,
                },
            },
        ],
    });

    binPrefixSumBindGroup[0] = device.createBindGroup({
        layout: binPrefixSumBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: binOffsetBuffer,
                },
            },
            {
                binding: 1,
                resource: {
                    buffer: binOffsetTempBuffer,
                },
            },
            {
                binding: 2,
                resource: {
                    buffer: binPrefixSumStepSizeBuffer,
                    size: 4,
                },
            },
        ],
    });

    binPrefixSumBindGroup[1] = device.createBindGroup({
        layout: binPrefixSumBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: binOffsetTempBuffer,
                },
            },
            {
                binding: 1,
                resource: {
                    buffer: binOffsetBuffer,
                },
            },
            {
                binding: 2,
                resource: {
                    buffer: binPrefixSumStepSizeBuffer,
                    size: 4,
                },
            },
        ],
    });

    particleSortBindGroup = device.createBindGroup({
        label: "particleSortBindGroup",
        layout: particleSortBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: particleBuffer,
                },
            },
            {
                binding: 1,
                resource: {
                    buffer: particleTempBuffer,
                },
            },
            {
                binding: 2,
                resource: {
                    buffer: binOffsetBuffer,
                },
            },
            {
                binding: 3,
                resource: {
                    buffer: binOffsetTempBuffer,
                },
            },
        ],
    });

    particleComputeForcesBindGroup = device.createBindGroup({
        label: "particleComputeForcesBindGroup",
        layout: particleComputeForcesBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: particleTempBuffer,
                },
            },
            {
                binding: 1,
                resource: {
                    buffer: particleBuffer,
                },
            },
            {
                binding: 2,
                resource: {
                    buffer: binOffsetBuffer,
                },
            },
            {
                binding: 3,
                resource: {
                    buffer: params_k_Buffer,
                },
            },
            {
                binding: 4,
                resource: {
                    buffer: params_g_Buffer,
                },
            },
            {
                binding: 5,
                resource: {
                    buffer: c_rep_Buffer,
                },
            }
        ],
    });
}


function generateSystem(systemDescription)
{
    const speciesCount = systemDescription.species.length;
    const kernelsCount = systemDescription.kernelsCount;
    const growthFuncsCount = systemDescription.growthFuncsCount;
    systemDescription.species = [];

    const rng = splitmix32(systemDescription.seed);

    for (var i = 0; i < speciesCount; ++i)
    {
        const color = [
            Math.pow(0.25 + rng() * 0.75, 2.2),
            Math.pow(0.25 + rng() * 0.75, 2.2),
            Math.pow(0.25 + rng() * 0.75, 2.2),
            1.0,
        ];

        var mu_k = [];
        var sigma_k = [];
        var w_k = [];
        var c_rep = [];
        for (var j = 0; j < speciesCount; ++j) {
            c_rep.push(1.0 + 1.0 * rng());
            for (var k = 0; k < kernelsCount; ++k) {
                mu_k.push(1.0 + 4.0 * rng());
                sigma_k.push(0.2 + 1.3 * rng());
                w_k.push(-0.1 + 0.2 * rng());
            }
        }

        var mu_g = [];
        var sigma_g = [];
        for (var j = 0; j < growthFuncsCount; ++j) {
            mu_g.push(-2.0 + 4.0 * rng());
            sigma_g.push(0.8 + 0.2 * rng());
        }

        systemDescription.species.push({
            color: color,
            mu_k: mu_k,
            sigma_k: sigma_k,
            w_k: w_k,
            mu_g: mu_g,
            sigma_g: sigma_g,
            c_rep: c_rep,
            spawnWeight: rng(),
        });
    }

    return systemDescription;
}

function initialSystem()
{
    var particleCount = 1024;
    var speciesCount = 1;
    var kernelsCount = 1;
    var growthFuncsCount = 1;
    var loopingBorders = false;
    var seed = randomSeed();

    const aspectRatio = window.screen.width / window.screen.height;
    var width = Math.round(12 * Math.sqrt(aspectRatio)) * 16;
    var height = Math.round(width / 64 / aspectRatio) * 32;

    const urlParams = new URLSearchParams(window.location.search);

    if (urlParams.has("particleCount"))
        particleCount = Number(urlParams.get("particleCount"));

    if (urlParams.has("speciesCount"))
        speciesCount = Number(urlParams.get("speciesCount"));

    if (urlParams.has("kernelsCount"))
        kernelsCount = Number(urlParams.get("kernelsCount"));

    if (urlParams.has("growthFuncsCount"))
        growthFuncsCount = Number(urlParams.get("growthFuncsCount"));

    if (urlParams.has("loopingBorders"))
        loopingBorders = urlParams.get("loopingBorders") == "true";

    if (urlParams.has("seed"))
        seed = Number(urlParams.get("seed")) >>> 0;

    if (urlParams.has("width"))
        width = Number(urlParams.get("width"));

    if (urlParams.has("height"))
        height = Number(urlParams.get("height"));

    const systemDescription = {
        particleCount: particleCount,
        species: new Array(speciesCount),
        kernelsCount: kernelsCount,
        growthFuncsCount: growthFuncsCount,
        simulationSize: [width, height],
        loopingBorders: loopingBorders,
        seed: seed,
    };
    return generateSystem(systemDescription);
}

function resize()
{
    if (!canvas)
        return;
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    hdrTexture = device.createTexture({
        format: hdrFormat,
        size: [canvas.width, canvas.height, 1],
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
    });

    hdrTextureView = hdrTexture.createView({});

    composeBindGroup = device.createBindGroup({
        layout: composeBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: hdrTextureView,
            },
            {
                binding: 1,
                resource: blueNoiseTextureView,
            },
        ],
    });
}

async function loadImage(url) {
    const res = await fetch(url);
    const blob = await res.blob();
    return await createImageBitmap(blob, { colorSpaceConversion: 'none' });
}

async function init()
{
    const buttonsTable = document.getElementById("buttonsTable");
    const toolsPanelStyle = window.getComputedStyle(document.getElementById("toolsPanel"), null);
    buttonsTable.style.width = buttonsTable.parentElement.clientWidth - parseFloat(toolsPanelStyle.getPropertyValue('padding-left')) - parseFloat(toolsPanelStyle.getPropertyValue('padding-right'));

    for (var element of document.getElementsByClassName('slider')) {
        const self = element;
        self.addEventListener('wheel', function(event) {
            self.value = Number(self.value) - event.deltaY / 120;
            self.dispatchEvent(new Event('input'));
        });
    }

    if (!document.body.requestFullscreen) {
        document.getElementById("fullscreenButton").style.display = 'none';
    }

    canvas = document.getElementById("mainCanvas");

    canvas.addEventListener('wheel', function(event) {
        const factor = Math.pow(1.25, event.deltaY / 120);
        cameraExtentXTarget *= factor;

        zoomAnchor = [
            2.0 * event.x / canvas.width - 1.0,
            1.0 - 2.0 * event.y / canvas.height,
        ];

        event.preventDefault();
    }, false);    

    canvas.addEventListener('mousedown', function(event) {
        if (event.button == 0) {
            actionPoint = [event.clientX, event.clientY];
            actionDrag = [0.0, 0.0];
        }
        if (event.button == 2) {
            mouseDrag = [event.clientX, event.clientY];
        }
        event.preventDefault();
    }, false);

    canvas.addEventListener('mouseup', function(event) {
        if (event.button == 0) {
            actionPoint = null;
            actionDrag = null;
        }
        if (event.button == 2) {
            mouseDrag = null;
        }
        event.preventDefault();
    }, false);

    canvas.addEventListener('contextmenu', function(event) {
        event.preventDefault();
    }, false);

    canvas.addEventListener('mousemove', function(event) {
        if (actionPoint) {
            actionDrag = [event.clientX - actionPoint[0], event.clientY - actionPoint[1]];
            actionPoint = [event.clientX, event.clientY];
        }

        if (mouseDrag) {
            const delta = [event.clientX - mouseDrag[0], event.clientY - mouseDrag[1]];

            cameraCenter[0] -= delta[0] / canvas.width * cameraExtentX * 2.0;
            cameraCenter[1] += delta[1] / canvas.height * cameraExtentY * 2.0;

            mouseDrag = [event.clientX, event.clientY];
        }

        event.preventDefault();
    }, false);

    canvas.addEventListener("touchstart", function(event) {
        for (const touch of event.changedTouches) {
            activeTouches.set(touch.identifier, [touch.pageX, touch.pageY]);
        }

        if (activeTouches.size == 3) {
            toolsPanelShown = !toolsPanelShown;
        }

        const now = window.performance.now() / 1000.0;;

        if (activeTouches.size == 1 && (now - lastTouchTime) < 0.5) {
            isDoubleTap = true;
        } else {
            isDoubleTap = false;
        }

        lastTouchTime = now;

        event.preventDefault();
    });

    canvas.addEventListener("touchmove", function(event) {
        const oldTouches = new Map(activeTouches);

        for (const touch of event.changedTouches) {
            activeTouches.set(touch.identifier, [touch.pageX, touch.pageY]);
        }

        if (oldTouches.size == 1 && activeTouches.size == 1) {
            const oldPosition = oldTouches.entries().next().value[1];
            const newPosition = activeTouches.entries().next().value[1];
            const delta = [newPosition[0] - oldPosition[0], newPosition[1] - oldPosition[1]];

            if (isDoubleTap) {
                actionPoint = newPosition;
                actionDrag = delta;
            } else {
                cameraCenter[0] -= delta[0] / canvas.width * cameraExtentX * 2.0;
                cameraCenter[1] += delta[1] / canvas.height * cameraExtentY * 2.0;
            }
        }

        if (oldTouches.size == 2 && activeTouches.size == 2) {
            const oldIterator = oldTouches.entries();
            const newIterator = activeTouches.entries();

            const oldPosition1 = oldIterator.next().value[1];
            const oldPosition2 = oldIterator.next().value[1];

            const newPosition1 = newIterator.next().value[1];
            const newPosition2 = newIterator.next().value[1];

            const oldCenter = [(oldPosition2[0] + oldPosition1[0]) / 2, (oldPosition2[1] + oldPosition1[1]) / 2];
            const newCenter = [(newPosition2[0] + newPosition1[0]) / 2, (newPosition2[1] + newPosition1[1]) / 2];

            zoomAnchor = [
                2.0 * newCenter[0] / canvas.width - 1.0,
                1.0 - 2.0 * newCenter[1] / canvas.height,
            ];

            const delta = [newCenter[0] - oldCenter[0], newCenter[1] - oldCenter[1]];

            const oldDelta = [oldPosition2[0] - oldPosition1[0], oldPosition2[1] - oldPosition1[1]];
            const newDelta = [newPosition2[0] - newPosition1[0], newPosition2[1] - newPosition1[1]];

            const oldDistance = Math.sqrt(oldDelta[0] * oldDelta[0] + oldDelta[1] * oldDelta[1]);
            const newDistance = Math.sqrt(newDelta[0] * newDelta[0] + newDelta[1] * newDelta[1]);

            cameraCenter[0] -= delta[0] / canvas.width * cameraExtentX * 2.0;
            cameraCenter[1] += delta[1] / canvas.height * cameraExtentY * 2.0;
            cameraExtentXTarget *= oldDistance / newDistance;
        }

        event.preventDefault();
    });

    canvas.addEventListener("touchend", function(event) {
        for (const touch of event.changedTouches) {
            activeTouches.delete(touch.identifier);
        }
        isDoubleTap = false;
        actionPoint = null;
        actionDrag = null;
        event.preventDefault();
    });

    canvas.addEventListener("touchcancel", function(event) {
        for (const touch of event.changedTouches) {
            activeTouches.delete(touch.identifier);
        }
        isDoubleTap = false;
        actionPoint = null;
        actionDrag = null;
    });

    window.addEventListener('keydown',function(event) {
        if (event.key == ' ') {
            pauseClicked();
            event.preventDefault();
        }

        if (event.key == 'c') {
            centerView();
            event.preventDefault();
        }

        if (event.key == 's') {
            toolsPanelShown = !toolsPanelShown;
            event.preventDefault();
        }

        if (event.key == 'd') {
            debugPanelShown = !debugPanelShown;
            event.preventDefault();
        }
    }, false);

    if (!navigator) {
        alert("Your browser doesn't support WebGPU (navigator is null)");
        return;
    }

    if (!navigator.gpu) {
        alert("Your browser doesn't support WebGPU (navigator.gpu is null)");
        return;
    }

    const adapter = await navigator.gpu?.requestAdapter();

    if (!adapter) {
        alert("Your browser doesn't support WebGPU (failed to create adapter)");
        return;
    }

    timestampQuerySupported = adapter.features.has('timestamp-query');

    device = await adapter?.requestDevice({
        requiredFeatures: timestampQuerySupported ? ['timestamp-query'] : [],
    });

    if (!device) {
        alert("Your browser doesn't support WebGPU (failed to create device)");
        return;
    }

    device.lost.then((info) => {
        console.error(`WebGPU device was lost: ${info.message}`);
    });

    // Add more aggressive error handling
    device.pushErrorScope('validation');
    device.pushErrorScope('out-of-memory');
    device.pushErrorScope('internal');

    setInterval(async () => {
        const validationError = await device.popErrorScope();
        const oomError = await device.popErrorScope();
        const internalError = await device.popErrorScope();
        
        if (validationError || oomError || internalError) {
            console.error('GPU Errors detected:', { validationError, oomError, internalError });
        }
        
        // Re-push scopes
        device.pushErrorScope('validation');
        device.pushErrorScope('out-of-memory');
        device.pushErrorScope('internal');
    }, 1000);

    context = canvas.getContext('webgpu');
    surfaceFormat = navigator.gpu.getPreferredCanvasFormat();
    context.configure({
        device,
        format: surfaceFormat,
    });

    cameraBuffer = device.createBuffer({
        size: 24,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
    });

    simulationOptionsBuffer = device.createBuffer({
        size: 64,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
    });

    const binFillSizeShaderModule = device.createShaderModule({
        code: binFillSizeShader,
    });

    const binPrefixSumShaderModule = device.createShaderModule({
        code: binPrefixSumShader,
    });

    const particleSortShaderModule = device.createShaderModule({
        code: particleSortShader,
    });

    const particleComputeForcesShaderModule = device.createShaderModule({
        code: particleComputeForcesShader,
    });

    const particleAdvanceShaderModule = device.createShaderModule({
        code: particleAdvanceShader,
    });

    const particleRenderShaderModule = device.createShaderModule({
        code: particleRenderShader,
    });

    const composeShaderModule = device.createShaderModule({
        code: composeShader,
    });

    particleBufferBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
        ],
    });

    particleBufferReadOnlyBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 1,
                visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
        ],
    });

    cameraBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'uniform',
                },
            },
        ],
    });

    cameraBindGroup = device.createBindGroup({
        layout: cameraBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: cameraBuffer,
                },
            },
        ],
    });

    simulationOptionsBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'uniform',
                },
            },
        ],
    });

    simulationOptionsBindGroup = device.createBindGroup({
        layout: simulationOptionsBindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: {
                    buffer: simulationOptionsBuffer,
                },
            },
        ],
    });

    binFillSizeBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
        ],
    });

    binPrefixSumBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: 2,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'uniform',
                    hasDynamicOffset: true,
                },
            },
        ],
    });

    particleSortBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: 2,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 3,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
        ],
    });

    particleComputeForcesBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: 2,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 3,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 4,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 5,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            }
        ],
    });

    composeBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {},
            },
            {
                binding: 1,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {},
            },
        ],
    });

    binClearSizePipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleBufferReadOnlyBindGroupLayout,
                simulationOptionsBindGroupLayout,
                binFillSizeBindGroupLayout,
            ],
            label: "binClearSizePipelineLayout",
        }),
        compute: {
            module: binFillSizeShaderModule,
            entryPoint: 'clearBinSize',
        },
        label: "binClearSizePipeline",
    });

    binFillSizePipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleBufferReadOnlyBindGroupLayout,
                simulationOptionsBindGroupLayout,
                binFillSizeBindGroupLayout,
            ],
            label: "binFillSizePipelineLayout",
        }),
        compute: {
            module: binFillSizeShaderModule,
            entryPoint: 'fillBinSize',
        },
        label: "binFillSizePipeline",
    });

    binPrefixSumPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                binPrefixSumBindGroupLayout,
            ],
            label: "binPrefixSumPipelineLayout",
        }),
        compute: {
            module: binPrefixSumShaderModule,
            entryPoint: 'prefixSumStep',
        },
        label: "binPrefixSumPipeline",
    });

    particleSortClearSizePipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleSortBindGroupLayout,
                simulationOptionsBindGroupLayout,
            ],
            label: "particleSortClearSizePipelineLayout",
        }),
        compute: {
            module: particleSortShaderModule,
            entryPoint: 'clearBinSize',
        },
        label: "particleSortClearSizePipeline",
    });

    particleSortPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleSortBindGroupLayout,
                simulationOptionsBindGroupLayout,
            ],
            label: "particleSortPipelineLayout",
        }),
        compute: {
            module: particleSortShaderModule,
            entryPoint: 'sortParticles',
        },
        label: "particleSortPipeline",
    });

    particleComputeForcesPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleComputeForcesBindGroupLayout,
                simulationOptionsBindGroupLayout,
            ],
            label: "particleComputeForcesPipelineLayout",
        }),
        compute: {
            module: particleComputeForcesShaderModule,
            entryPoint: 'computeForces',
        },
        label: "particleComputeForcesPipeline",
    });

    particleAdvancePipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleBufferBindGroupLayout,
                simulationOptionsBindGroupLayout,
            ],
            label: "particleAdvancePipelineLayout",
        }),
        compute: {
            module: particleAdvanceShaderModule,
            entryPoint: 'particleAdvance',
        },
        label: "particleAdvancePipeline",
    });

    particleRenderGlowPipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleBufferReadOnlyBindGroupLayout,
                cameraBindGroupLayout,
            ],
            label: "particleRenderGlowPipelineLayout",
        }),
        vertex: {
            module: particleRenderShaderModule,
            entryPoint: 'vertexGlow',
        },
        primitive: {
            topology: 'triangle-list',
        },
        fragment: {
            module: particleRenderShaderModule,
            entryPoint: 'fragmentGlow',
            targets: [
                {
                    format: hdrFormat,
                    blend: {
                        color: {
                            srcFactor: 'src-alpha',
                            dstFactor: 'one',
                        },
                        alpha: {
                            srcFactor: 'one',
                            dstFactor: 'one',
                        },
                    },
                },
            ],
        }
    });

    particleRenderPipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleBufferReadOnlyBindGroupLayout,
                cameraBindGroupLayout,
            ],
            label: "particleRenderPipelineLayout",
        }),
        vertex: {
            module: particleRenderShaderModule,
            entryPoint: 'vertexCircle',
        },
        primitive: {
            topology: 'triangle-list',
        },
        fragment: {
            module: particleRenderShaderModule,
            entryPoint: 'fragmentCircle',
            targets: [
                {
                    format: hdrFormat,
                    blend: {
                        color: {
                            srcFactor: 'src-alpha',
                            dstFactor: 'one',
                        },
                        alpha: {
                            srcFactor: 'one',
                            dstFactor: 'one',
                        },
                    },
                },
            ],
        }
    });

    particleRenderPointPipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                particleBufferReadOnlyBindGroupLayout,
                cameraBindGroupLayout,
            ],
            label: "particleRenderPointPipelineLayout",
        }),
        vertex: {
            module: particleRenderShaderModule,
            entryPoint: 'vertexPoint',
        },
        primitive: {
            topology: 'triangle-list',
        },
        fragment: {
            module: particleRenderShaderModule,
            entryPoint: 'fragmentPoint',
            targets: [
                {
                    format: hdrFormat,
                    blend: {
                        color: {
                            srcFactor: 'src-alpha',
                            dstFactor: 'one',
                        },
                        alpha: {
                            srcFactor: 'one',
                            dstFactor: 'one',
                        },
                    },
                },
            ],
        }
    });

    composePipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                composeBindGroupLayout,
            ],
            label: "composePipelineLayout",
        }),
        vertex: {
            module: composeShaderModule,
            entryPoint: 'vertexMain',
        },
        primitive: {
            topology: 'triangle-list',
        },
        fragment: {
            module: composeShaderModule,
            entryPoint: 'fragmentMain',
            targets: [
                {
                    format: surfaceFormat,
                },
            ],
        }
    });

    const blueNoiseImage = await loadImage("/webgpu/blue-noise.png");
    blueNoiseTexture = device.createTexture({
        format: 'rgba8unorm-srgb',
        size: [blueNoiseImage.width, blueNoiseImage.height],
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
    });
    device.queue.copyExternalImageToTexture(
        {source: blueNoiseImage},
        {texture: blueNoiseTexture},
        {width: blueNoiseImage.width, height: blueNoiseImage.height},
    );

    blueNoiseTextureView = blueNoiseTexture.createView({});

    resize();

    loadSystem(initialSystem());
    centerView();

    redraw();
    createAudioChunk();
}

function initAudio()
{
    // audio setup
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    chunkNumSamplesPerChannel = audioCtx.sampleRate * chunkDurationSeconds;
    chunkNumSamples = numChannels * chunkNumSamplesPerChannel;
    chunkBufferSize = Float32Array.BYTES_PER_ELEMENT * chunkNumSamples;
    chunkBuffer = device.createBuffer({
        size: chunkBufferSize,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
    });

    // We did not cover this in the workshop: storage & uniform buffers can't be read back to the CPU directly.
    // Instead, we need to copy the data to an extra buffer with the MAP_READ & COPY_DST usages.
    // To get the data to the CPU, we need to map the buffer to CPU memory and then copy the mapped memory to a JavaScript ArrayBuffer.
    // Note that a mapped buffer must not be used in a command encoder.
    chunkMapBuffer = device.createBuffer({
        size: chunkBufferSize,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
    });

    timeInfoBuffer = device.createBuffer({
        size: Float32Array.BYTES_PER_ELEMENT * 1,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    audioRingBuffer = new AudioRingBuffer(4);

    const audioShaderModule = device.createShaderModule({
        code: audioShader
    });

    audioBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'uniform',
                },
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
        ],
    });

    audioPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [
                audioBindGroupLayout,
                particleComputeForcesBindGroupLayout,
                simulationOptionsBindGroupLayout,
                cameraBindGroupLayout,
            ],
            label: "audioPipelineLayout",
        }),
        compute: {
            module: audioShaderModule,
            entryPoint: 'synthezise',
            constants: {
                SAMPLING_RATE: audioCtx.sampleRate,
                WORKGROUP_SIZE: workGroupSize,
            }
        },
        label: "audioPipeline",
    });

    audioBindGroup = device.createBindGroup({
        layout: audioBindGroupLayout,
        entries: [
            {binding: 0, resource: {buffer: timeInfoBuffer}},
            {binding: 1, resource: {buffer: chunkBuffer}},
        ]
    });
}

window.onload = init;
window.onresize = resize;

function pauseClicked()
{
    paused = !paused;
    document.getElementById("pauseButton").innerText = paused ? "Continue" : "Pause";
}

function updateParticleCount()
{
    const newParticleCount = Math.round(Math.pow(2, document.getElementById("particleCountSlider").value));

    const systemDescription = currentSystemDescription;
    systemDescription.particleCount = newParticleCount;
    loadSystem(systemDescription);
}

function updateSpeciesCount()
{
    const newSpeciesCount = Math.round(document.getElementById("speciesCountSlider").value);

    const systemDescription = currentSystemDescription;
    systemDescription.species = new Array(newSpeciesCount);
    systemDescription.seed = randomSeed();
    loadSystem(generateSystem(systemDescription));
}

function updateKernelsCount()
{
    const newKernelsCount = Math.round(document.getElementById("kernelsCountSlider").value);

    const systemDescription = currentSystemDescription;
    systemDescription.kernelsCount = newKernelsCount;
    systemDescription.seed = randomSeed();
    loadSystem(generateSystem(systemDescription));
}

function updateGrowthFuncsCount()
{
    const newGrowthFuncsCount = Math.round(document.getElementById("growthFuncsCountSlider").value);

    const systemDescription = currentSystemDescription;
    systemDescription.growthFuncsCount = newGrowthFuncsCount;
    systemDescription.seed = randomSeed();
    loadSystem(generateSystem(systemDescription));
}

function updateSimulationSize()
{
    const newWidth = document.getElementById("simulationWidthSlider").value * 64;
    const newHeight = document.getElementById("simulationHeightSlider").value * 64;

    const systemDescription = currentSystemDescription;
    systemDescription.simulationSize = [newWidth, newHeight];
    loadSystem(systemDescription);
}

function updateLoopingBorders()
{
    const newLoopingBorders = document.getElementById("loopingBorders").checked;

    currentSystemDescription.loopingBorders = newLoopingBorders;
    loopingBorders = newLoopingBorders;
}

function updatePlayAudio()
{
    const newPlayAudio = document.getElementById("playAudio").checked;

    if (newPlayAudio) {
        if (!audioCtx) {
            initAudio();
        }

        audioCtx.resume();
        audioPaused = false;

    } else {
        audioCtx.suspend();
        audioPaused = true;
    }
}

async function saveSettings()
{
    const handle = await window.showSaveFilePicker({
        id: "particle-life",
        startIn: "downloads",
        suggestedName: "particle-life-system.json",
        types: [{
            description: "JSON file",
            accept: {"application/json": [".json"]},
        }],
    });

    const writable = await handle.createWritable();
    await writable.write(JSON.stringify(currentSystemDescription, null, 2));
    await writable.close();
}

async function loadSettings()
{
    const [handle] = await window.showOpenFilePicker({
        id: "particle-life",
        startIn: "downloads",
        suggestedName: "particle-life-system.json",
        types: [{
            description: "JSON file",
            accept: {"application/json": [".json"]},
        }],
    });

    const file = await handle.getFile();
    const data = await file.text();
    loadSystem(JSON.parse(data));
    customRules = true;
}

async function copyUrl()
{    
    if (customRules) {
        alert("Copying URL might not work correctly with custom rules");
    }

    const location = window.location;
    var url = location.protocol + "//" + location.host + location.pathname + `?particleCount=${particleCount}&speciesCount=${speciesCount}&friction=${friction}&centralForce=${centralForce}&symmetricForces=${symmetricForces}&loopingBorders=${loopingBorders}&seed=${currentSystemDescription.seed}`;

    await navigator.clipboard.writeText(url);
}

async function fullscreen()
{
    if (document.fullscreen) {
        await document.exitFullscreen();
        document.getElementById("fullscreenButton").innerText = "Fullscreen";
    } else {
        await document.body.requestFullscreen();
        document.getElementById("fullscreenButton").innerText = "Exit fullscreen";
    }
}

        </script>
        <style>
            #mainCanvas {
                position: fixed;
            }

            #copyright {
                position: fixed;
                left: 12px;
                bottom: 12px;
                color: #bbb;
                font-family: monospace;
                font-size: 14;
            }

            .panel {
                background-color: rgba(50, 50, 50, 0.5);
                border-radius: 12px;
                border: 2px solid #eee;
                color: #eee;
                padding: 18px;
                backdrop-filter: blur(4px);
                font-family: monospace;
                font-size: 14;
            }

            #toolsPanel {
                position: fixed;
                left: 24px;
                top: 24px;
            }

            #debugPanel {
                position: fixed;
                right: 24px;
                top: 24px;
            }

            #debugInfo {
                white-space: pre;
            }

            a {
                color: #bbb;
                text-decoration: none;
            }

            a:hover {
                color: #eee;
                text-decoration: underline;
            }

            label {
                font-family: monospace;
                font-size: 14;
                color: #eee;
            }

            .checkboxContainer input {
                position: absolute;
                opacity: 0;
                cursor: pointer;
                height: 0;
                width: 0;
            }

            .checkboxContainer {
                display: block;
                position: relative;
                cursor: pointer;
                padding-left: 28px;
                padding-top: 14px;
                padding-bottom: 10px;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }

            .customCheckbox {
                position: absolute;
                top: 12px;
                left: 0px;
                height: 20px;
                width: 20px;
                background-color: #eee;
                border-radius: 4px;
            }

            .checkboxContainer input:active ~ .customCheckbox {
                top: 13px;
                left: 1px;
            }

            .checkboxContainer:hover input ~ .customCheckbox {
                background-color: #999;
            }

            .checkboxContainer input:checked ~ .customCheckbox {
                background-color: #777;
            }

            .checkboxContainer:hover input:checked ~ .customCheckbox {
                background-color: #555;
            }

            .customCheckbox:after {
                content: "";
                position: absolute;
                display: none;
            }

            .checkboxContainer input:checked ~ .customCheckbox:after {
                display: block;
            }

            .checkboxContainer .customCheckbox:after {
                left: 6px;
                top: 2px;
                width: 5px;
                height: 10px;
                border: solid white;
                border-width: 0 3px 3px 0;
                -webkit-transform: rotate(45deg);
                -ms-transform: rotate(45deg);
                transform: rotate(45deg);
            }

            .button {
                background-color: #777;
                padding: 4px;
                border-radius: 4px;
                text-align: center;
                cursor: pointer;
            }

            .button:hover {
                background-color: #555;
            }

            .button:active {
                background-color: #444;
            }

            .rowBreak {
                height: 8px;
            }

            .sliderContainer input {
                -webkit-appearance: none;
                appearance: none;
                height: 4px;
                border-radius: 2px;
                background: #ccc;
                outline: none;
            }

            .sliderContainer input:hover {
                background: #999;
            }

            .sliderContainer input::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 16px;
                height: 16px;
                border-radius: 8px;
                border: 2px solid #ccc;
                background: #777;
                cursor: pointer;
            }

            .sliderContainer input::-webkit-slider-thumb:hover  {
                background: #555;
                border: 2px solid #999;
            }

            table {
                table-layout: fixed;
                border: none;
                border-collapse: collapse;
                color: #eee;
            }
        </style>
    </head>
    <body>
        <canvas id="mainCanvas"></canvas>
        <div id="toolsPanel" class="panel">
            <div class="sliderContainer">
                <input type="range" min="10" max="20" value="16" class="slider" id="particleCountSlider" oninput="updateParticleCount();">
                <span id="particleCountText">65536 particles</span>
            </div>
            <div class="rowBreak"></div>
            <div class="sliderContainer">
                <input type="range" min="1" max="20" value="8" class="slider" id="speciesCountSlider" oninput="updateSpeciesCount();">
                <span id="speciesCountText">8 particle types</span>
            </div>
            <div class="rowBreak"></div>
            <div class="sliderContainer">
                <input type="range" min="1" max="20" value="8" class="slider" id="kernelsCountSlider" oninput="updateKernelsCount();">
                <span id="kernelsCountText">1 kernel</span>
            </div>
            <div class="rowBreak"></div>
            <div class="sliderContainer">
                <input type="range" min="1" max="20" value="8" class="slider" id="growthFuncsCountSlider" oninput="updateGrowthFuncsCount();">
                <span id="growthFuncsCountText">1 growth function</span>
            </div>
            <div class="rowBreak"></div>
            <div class="sliderContainer">
                <input type="range" min="1" max="50" value="16" class="slider" id="simulationWidthSlider" oninput="updateSimulationSize();">
                <span id="simulationWidthText">Width: 256</span>
            </div>
            <div class="rowBreak"></div>
            <div class="sliderContainer">
                <input type="range" min="1" max="50" value="9" class="slider" id="simulationHeightSlider" oninput="updateSimulationSize();">
                <span id="simulationHeightText">Height: 256</span>
            </div>
            <div class="rowBreak"></div>
            <label class="checkboxContainer">
                Looping borders
                <input type="checkbox" id="loopingBorders" onclick="updateLoopingBorders();" />
                <span class="customCheckbox"></span>
            </label>
            <div class="rowBreak"></div>
            <table id="buttonsTable">
                <tr>
                    <td><div class="button" id="pauseButton" onclick="pauseClicked();">Pause</div></td>
                    <td><div class="button" id="centerViewButton" onclick="centerView();">Center view</div></td>
                </tr>
                <tr>
                    <td><div class="button" id="restartButton" onclick="loadSystem(currentSystemDescription);">Restart</div></td>
                    <td><div class="button" id="randomizeButton" onclick="currentSystemDescription.seed = randomSeed(); loadSystem(generateSystem(currentSystemDescription));">Randomize</div></td>
                </tr>
                <tr>
                    <td><div class="button" id="saveSettingsButton" onclick="saveSettings();">Save system</div></td>
                    <td><div class="button" id="loadSettingsButton" onclick="loadSettings();">Load system</div></td>
                </tr>
                <tr>
                    <td><div class="button" id="copyUrlButton" onclick="copyUrl();">Copy URL</div></td>
                    <td><div class="button" id="fullscreenButton" onclick="fullscreen();">Fullscreen</div></td>
                </tr>
            </table>
            <label class="checkboxContainer">
                Play audio
                <input type="checkbox" id="playAudio" onclick="updatePlayAudio();" />
                <span class="customCheckbox"></span>
            </label>
            
            <div class="rowBreak"></div>
            <div><center>[S] or three-tap to hide this menu</center></div>
            <div><center>LMB or double-tap to interact</center></div>
        </div>
        <div id="debugPanel" class="panel">
            <div id="debugInfo">Debug info</div>
        </div>
    </body>
</html>
